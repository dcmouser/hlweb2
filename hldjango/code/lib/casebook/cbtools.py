# utilities usedful for running caseboook commandline tools, etc.

from lib.casebook.casebookDefines import *
from lib.casebook.jrinterpCasebook import JrInterpreterCasebook
from .jrast import AstValString, AstValNumber, AstValBool, AstValIdentifier, AstValList, AstValDict, AstValNull, AstValObject, AstValFunction
from .jrcbfuncs import CbFunc, CbParam

# my libs
from lib.jr import jrfuncs
from lib.jr.jrfuncs import jrprint

# python modules
import argparse
import os
import time






class CbTools:

    def __init__(self):
        self.debugMode = True
        self.jrinterp = None

    def processCommandline(self):
        appName = DefCbBuildString + " commmandline tool"
        appInfo = DefCbAuthorString
        jrprint("Running {}..".format(appName))
        #
        parser = argparse.ArgumentParser(prog = appName, description = appInfo)
        parser.add_argument('-c', '--command', required=False)
        parser.add_argument('-j', '--job', required=False)
        parser.add_argument('-w', '--workingdir', required=False)
        args = parser.parse_args()
        #
        workingdir = args.workingdir
        if (workingdir):
            jrprint("Changing working directory to: {}".format(workingdir))
            os.chdir(workingdir)
        #
        job = args.job
        if (job is not None) and (job!=""):
            args.command = "job"
        #
        self.runCommand(args.command, args)


    def getMakeCasebookInterp(self, flagUseCachedCopy):
        if (not flagUseCachedCopy) or (self.jrinterp is None):
            expectSubdirectoriesForLocalMediaFiles = False
            self.jrinterp = JrInterpreterCasebook(self.debugMode, expectSubdirectoriesForLocalMediaFiles)
        return self.jrinterp

    def getEnvironment(self):
        jrinterp = self.getMakeCasebookInterp(True)
        return jrinterp.getEnvironment()


    def runCommand(self, command, args):
        jrprint("Executing command {}..".format(command))
        if (command=="makedocs"):
            self.runCommandMakeDocs(args)
        elif (command=="job"):
            self.runCommandJob(args)
        else:
            raise Exception(" Faatal error, command unknown: {}".format(command))


    def runCommandMakeDocs(self, args):
        outFilePath = "./autoGeneratedDocs.html"
        jrprint("Writing auto-generated documentation to {}..".format(outFilePath))

        # opten file
        fileOut = open(outFilePath, "w", encoding="utf-8")

        # write definitions
        self.exportDeclarationDefinitionsAsHtml(fileOut)

        # close file
        fileOut.close()

        return "Documentation explored to {}.".format(outFilePath)


    def runCommandJob(self, args):
        progressCallback = None
        #
        jobFilePath = args.job
        jrprint("Running job file {}..".format(jobFilePath))
        # load job file json
        job = jrfuncs.loadJsonFromFile(jobFilePath, True, "utf-8")
        jrprint(job)

        jrinterp = self.getMakeCasebookInterp(True)
        jrinterp.runJobs([job], progressCallback)
































    # 
    def exportDeclarationDefinitionsAsHtml(self, fileOut):
        # create interpretter with env, and loaded function definitions
        env = self.getEnvironment()
        envDict = env.getEnvDict()
        keys = envDict.keys()
        keys = sorted(keys)

        # write out global data
        fileOut.write("<h1>GLOBAL DATA</h1>\n<br/>\n")
        for k in keys:
            v = envDict[k]
            if (v.getIsFunction()):
                # no functions here
                continue
            fileOut.write("<h2>" + k + "</h2>\n")
            props = self.buildNicePropsForEnvVariable(v)
            html = self.makeHtmlFromNiceProps(props)
            if (html!=""):
                fileOut.write(html + "\n<br/>\n")
            

        # write out function definitions
        fileOut.write("\n<br/>\n<br/>\n<br/>\n")
        fileOut.write("<h1>BUILT-IN FUNCTION DEFINITIONS</h1>\n<br/>\n")
        for k in keys:
            v = envDict[k]
            if (not v.getIsFunction()):
                # no functions here
                continue
            fileOut.write("<h2>" + k + "</h2>\n")
            props = self.buildNicePropsForEnvVariable(v)
            html = self.makeHtmlFromNiceProps(props)
            if (html!=""):
                fileOut.write(html + "\n<br/>\n")



    def buildNicePropsForEnvVariable(self, var):
        wrappedVal = var.getUnWrappedValue(None, None)
        #
        propDict = {}
        if (wrappedVal is None):
            return {"VALUE": "NULL"}
        #
        if (isinstance(wrappedVal, CbFunc)):
            propDict["Description"] = wrappedVal.getDescription()
            propDict["Usage"] = wrappedVal.getUsageInfoSimple()
            paramHtml = wrappedVal.getParameterInfoHtml()
            if (paramHtml!=""):
                propDict["Parameters"] = paramHtml

        elif (isinstance(wrappedVal, list)):
            propDict["LIST"] = str(wrappedVal)
        elif (isinstance(wrappedVal, dict)):
            if (len(wrappedVal)==0):
                propDict["DICT"] = "EMPTY"
            else:
                return wrappedVal
        elif (isinstance(wrappedVal, AstValObject)):
            return vars(wrappedVal)
        else:
            propDict["VALUE"] = str(wrappedVal)
        # default
        return propDict





    def makeHtmlFromNiceProps(self, props):
        if (len(props)==0):
            return ("")
        retvHtml = "<ul>\n"
        for k,v in props.items():
            v = str(v)
            if (k=="Description"):
                html = v
            else:
                html = k + ": " + v
            retvHtml += "<li>" + html + "</li>\n"
        retvHtml += "</ul>\n"
        return retvHtml


